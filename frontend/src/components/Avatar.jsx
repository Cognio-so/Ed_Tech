/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 .\public\models\686bb46fa70935d615427a7a.glb -o src/components/Avatar.jsx -r public 
*/
'use client'
import React, { useEffect, useRef, useState } from 'react'
import { useAnimations, useFBX, useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'

export function Avatar(props) {
  const { lipSyncData, isConnected, ...otherProps } = props;
  const group = useRef();
  const headRef = useRef();
  const teethRef = useRef();
  
  const {nodes, materials} = useGLTF('/models/686bb46fa70935d615427a7a.glb');
  const {animations: breathingAnimation} = useFBX('/animations/Breathing.fbx');
  const {animations: angryAnimation} = useFBX('/animations/Angry.fbx');
  const {animations: standingAnimation} = useFBX('/animations/Standing.fbx');

  breathingAnimation[0].name = 'breathing';
  angryAnimation[0].name = 'angry';
  standingAnimation[0].name = 'standing';
  
  const prepareAnimation = (anim) => {
    const validTracks = anim.tracks.filter(track => {
      const trackName = track.name;
      return !trackName.includes("Armature.quaternion");
    });
    
    return {
      ...anim,
      tracks: validTracks
    };
  };
  
  const preparedAnimations = [
    prepareAnimation(breathingAnimation[0]),
    prepareAnimation(angryAnimation[0]),
    prepareAnimation(standingAnimation[0])
  ];
  
  // Change animation based on connection status
  const [animation, setAnimation] = useState('breathing');
  const [availableTargets, setAvailableTargets] = useState([]);

  const {actions} = useAnimations(preparedAnimations, group);

  // Update animation when connection status changes
  useEffect(() => {
    const newAnimation = isConnected ? 'breathing' : 'standing';
    setAnimation(newAnimation);
  }, [isConnected]);

  useEffect(() => {
    if (actions[animation]) {
      actions[animation].reset().fadeIn(0.5).play();
      return () => {
        if (actions[animation]) {
          actions[animation].fadeOut(0.5);
        }
      };
    }
  }, [animation, actions]);

  // Log available morph targets once
  useEffect(() => {
    setTimeout(() => {
      if (headRef.current?.morphTargetDictionary) {
        const targets = Object.keys(headRef.current.morphTargetDictionary);
        setAvailableTargets(targets);
        console.log('ðŸŽ­ Available morph targets:', targets);
        
        // Show which ones might be mouth-related
        const mouthTargets = targets.filter(name => 
          name.toLowerCase().includes('mouth') ||
          name.toLowerCase().includes('jaw') ||
          name.toLowerCase().includes('lip') ||
          name.toLowerCase().includes('viseme')
        );
        console.log('ðŸ‘„ Mouth-related targets:', mouthTargets);
      }
    }, 1000);
  }, []);

  // Simple, direct lip sync application
  useFrame(() => {
    if (lipSyncData && headRef.current?.morphTargetInfluences && headRef.current?.morphTargetDictionary) {
      const influences = headRef.current.morphTargetInfluences;
      const targets = headRef.current.morphTargetDictionary;
      
      // Check if we have any lip sync data
      const hasLipSync = Object.values(lipSyncData).some(val => val > 0.01);
      
      if (hasLipSync) {
        // Reset all influences to 0 first
        for (let i = 0; i < influences.length; i++) {
          influences[i] = 0;
        }
        
        // Apply lip sync to ANY available morph targets
        Object.keys(targets).forEach(targetName => {
          const index = targets[targetName];
          const lowerName = targetName.toLowerCase();
          
          // Map to any mouth-related morph targets we can find
          if (lowerName.includes('mouth') || lowerName.includes('jaw')) {
            if (lowerName.includes('open') || lowerName.includes('a')) {
              influences[index] = lipSyncData.A;
            } else if (lowerName.includes('smile') || lowerName.includes('e')) {
              influences[index] = lipSyncData.E;
            } else if (lowerName.includes('narrow') || lowerName.includes('i')) {
              influences[index] = lipSyncData.I;
            } else if (lowerName.includes('round') || lowerName.includes('o')) {
              influences[index] = lipSyncData.O;
            } else if (lowerName.includes('funnel') || lowerName.includes('u')) {
              influences[index] = lipSyncData.U;
            } else {
              // If we can't identify the specific type, use general mouth movement
              const totalMovement = (lipSyncData.A + lipSyncData.E + lipSyncData.I + lipSyncData.O + lipSyncData.U) / 5;
              influences[index] = totalMovement;
            }
          }
          
          // Also try viseme targets if they exist
          if (lowerName.includes('viseme')) {
            if (lowerName.includes('aa') || lowerName.includes('a')) {
              influences[index] = lipSyncData.A;
            } else if (lowerName.includes('e')) {
              influences[index] = lipSyncData.E;
            } else if (lowerName.includes('i')) {
              influences[index] = lipSyncData.I;
            } else if (lowerName.includes('o')) {
              influences[index] = lipSyncData.O;
            } else if (lowerName.includes('u')) {
              influences[index] = lipSyncData.U;
            }
          }
        });
      }
    }
  });

  return (
    <group {...otherProps} dispose={null} ref={group}>
      <primitive object={nodes.Hips} />
      <skinnedMesh geometry={nodes.Wolf3D_Hair.geometry} material={materials.Wolf3D_Hair} skeleton={nodes.Wolf3D_Hair.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Body.geometry} material={materials.Wolf3D_Body} skeleton={nodes.Wolf3D_Body.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Bottom.geometry} material={materials.Wolf3D_Outfit_Bottom} skeleton={nodes.Wolf3D_Outfit_Bottom.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Footwear.geometry} material={materials['aleksandr@readyplayer']} skeleton={nodes.Wolf3D_Outfit_Footwear.skeleton} />
      <skinnedMesh geometry={nodes.Wolf3D_Outfit_Top.geometry} material={materials.Wolf3D_Outfit_Top} skeleton={nodes.Wolf3D_Outfit_Top.skeleton} />
      <skinnedMesh name="EyeLeft" geometry={nodes.EyeLeft.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeLeft.skeleton} morphTargetDictionary={nodes.EyeLeft.morphTargetDictionary} morphTargetInfluences={nodes.EyeLeft.morphTargetInfluences} />
      <skinnedMesh name="EyeRight" geometry={nodes.EyeRight.geometry} material={materials.Wolf3D_Eye} skeleton={nodes.EyeRight.skeleton} morphTargetDictionary={nodes.EyeRight.morphTargetDictionary} morphTargetInfluences={nodes.EyeRight.morphTargetInfluences} />
      <skinnedMesh 
        ref={headRef}
        name="Wolf3D_Head" 
        geometry={nodes.Wolf3D_Head.geometry} 
        material={materials.Wolf3D_Skin} 
        skeleton={nodes.Wolf3D_Head.skeleton} 
        morphTargetDictionary={nodes.Wolf3D_Head.morphTargetDictionary} 
        morphTargetInfluences={nodes.Wolf3D_Head.morphTargetInfluences} 
      />
      <skinnedMesh 
        ref={teethRef}
        name="Wolf3D_Teeth" 
        geometry={nodes.Wolf3D_Teeth.geometry} 
        material={materials.Wolf3D_Teeth} 
        skeleton={nodes.Wolf3D_Teeth.skeleton} 
        morphTargetDictionary={nodes.Wolf3D_Teeth.morphTargetDictionary} 
        morphTargetInfluences={nodes.Wolf3D_Teeth.morphTargetInfluences} 
      />
    </group>
  )
}

useGLTF.preload('/models/686bb46fa70935d615427a7a.glb')